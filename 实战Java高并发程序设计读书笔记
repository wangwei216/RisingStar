《第二章：Java并行程序基础》

（1）.线程的六种状态：
  new
  runnable
  blocked
  waiting
  time_waiting
  terminated
  
（2）.线程的几个常用的方法
1.start（）表示在线程调用之后就处于就绪状态，等待着CPU来去执行
2.stop（）方法在停止线程的时候，建议不要使用，不然会导致数据的不一致性，线程会执行完程序之后，自己结束。
3.interrupt（）这个其实有两个方法，一个是正常的方法目的是中断当前线程，还有一个是静态的interrupt（）方法，这个不仅是中断线程而且还会清除当前线程的标志位
4.isInterrupt（）这个方法是正常判断当前线程是不是被中断了，Boolean类型的返回结果
5.sleep（）这个方法是相当于线程抱着锁睡觉
6.wait（）和notify（）方法两者一般是需要配合使用的，可以实现线程之间的通信，但是他们其实并不是属于Thread线程类中的方法
  他们在任何对象中都可以使用，当调用对象A调用wait（）方法之后，A对象所在的线程就会在这个A对象上进行等待（其实就是进入了A对象所在的这个等待对列中等待）
  当有其他线程中的A对象再去调用notify（）方法之后，那么它就会从当前等待对列中等待的线程中随机唤醒一个线程，当然如果想唤醒全部的话，可以调用notifyAll()方法
注意：当对象A调用wait（）方法时，不能是随便在哪都能调用的 ，必须是需要先获取目标对象的一个监视器，因此也就是必须需要在Synchronize代码块下才可以
7.join（）其实是用在各个线程之间的协作时来使用的，如果一个线程要加入另一个线程，那我就等着这个线程一起再走
8.yield（）这个就是先暂时让出CPU的调用，让别的线程先去被执行，但是虽然我这个线程让出了，但是我还是会去竞争CPU，但是能不能竞争的到就在说了

（3）.volitile与java的内存模型
  可见性
  有序性
  原子性
  
 (4）.synchronize有关的
  这里需要注意一下几种加锁的位置：
  1.锁类对象
  2.锁实例对象
  
  《第三章：JUC并发包》
  
 （1）.ReentrantLock的用法
      1.
   
 （2）.ReentrantLock中的condition类的用法
      1.其实就是实现的和synchronize中的wait和notify方法一样的功能，但是在ReentrantLock中使用的是await（）和singal（）和singalAll（）来进行代替的
      2.
 
 （3）.Semaphore信号量的用法
      其实是通过Semaphore构造器可以指定N个信号量，和指定是否公平锁，通过指定的这个信号量的个数来保证进来的线程的个数只有N个，超过N个的线程都不能执行
      
 （4）.ReadWriteLock的用法
      这个是适用于那种读操作比较多的情况，并且读读之间不互斥，读写之间互斥，写写之间也互斥，为了解决其他的锁无论是全部读还是读写之间他们都是串行化同步的，
      但是这个读写锁可以最大化的保证了读读操作比较多的效率问题
      
（5）.倒计时器CountDownLatch的用法

（6）.循环栅栏CyclicBarrier的用法

（7）.线程阻塞工具：LockSupport的用法


