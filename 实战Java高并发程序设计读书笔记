《第二章：Java并行程序基础》

（1）.线程的六种状态：
  new
  runnable
  blocked
  waiting
  time_waiting
  terminated
  
（2）.线程的几个常用的方法
1.start（）表示在线程调用之后就处于就绪状态，等待着CPU来去执行
2.stop（）方法在停止线程的时候，建议不要使用，不然会导致数据的不一致性，线程会执行完程序之后，自己结束。
3.interrupt（）这个其实有两个方法，一个是正常的方法目的是中断当前线程，还有一个是静态的interrupt（）方法，这个不仅是中断线程而且还会清除当前线程的标志位
4.isInterrupt（）这个方法是正常判断当前线程是不是被中断了，Boolean类型的返回结果
5.sleep（）这个方法是相当于线程抱着锁睡觉
6.wait（）和notify（）方法两者一般是需要配合使用的，可以实现线程之间的通信，但是他们其实并不是属于Thread线程类中的方法
  他们在任何对象中都可以使用，当调用对象A调用wait（）方法之后，A对象所在的线程就会在这个A对象上进行等待（其实就是进入了A对象所在的这个等待对列中等待）
  当有其他线程中的A对象再去调用notify（）方法之后，那么它就会从当前等待对列中等待的线程中随机唤醒一个线程，当然如果想唤醒全部的话，可以调用notifyAll()方法
注意：当对象A调用wait（）方法时，不能是随便在哪都能调用的 ，必须是需要先获取目标对象的一个监视器，因此也就是必须需要在Synchronize代码块下才可以
7.join（）其实是用在各个线程之间的协作时来使用的，如果一个线程要加入另一个线程，那我就等着这个线程一起再走
8.yield（）这个就是先暂时让出CPU的调用，让别的线程先去被执行，但是虽然我这个线程让出了，但是我还是会去竞争CPU，但是能不能竞争的到就在说了

（3）.volitile与java的内存模型
  可见性
  有序性
  原子性
  
 (4）.synchronize有关的
  这里需要注意一下几种加锁的位置：
  1.锁类对象
  2.锁实例对象
  
  《第三章：JUC并发包》
  
 （1）.
  
  
