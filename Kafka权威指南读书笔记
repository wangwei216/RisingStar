              《第3章：kafka生产者-往kafka中导入数据》
1. 生产者必须要有的三个参数：
    bootstrap.server表示kafka的ip和端口地址
    对key的序列化
    对value的序列化
    
2. 发送消息主要有以下3种方式。
  发送并忘记的发送方式（有可能这种方式发送的消息会丢失）
  同步的发送方式（他会返回一个Future对象，然后调用get方法进行阻塞）
  异步的发送方式

              《第4章：kafka消费者从kafka中读取数据》
1. 消费者和消费组的一些概念
   首先一个消费者群组消费的是同一个topic主题，并且群组中的成员不能重复消费同一个topic主题的数据（这个是核心）
   不同的消费组可以消费同一个topic主题，一个消费者组中如果有多个消费者成员，那么一个成员只能消费一部分分区
   第一个进入群组的成员就是群主，
   
2. 消费者的配置--同一个 Consumer Group 里面的 Consumer 是如何知道该消费哪些分区里面的数据呢？
   1）可以通过的这个参数来进行配置kafka的分配策略partition.assignment.strategy，有RoundRobin（策略会给所有消费者分配相同数量的分区（或最多就差1个分区）） 
      和Range（这个是默认第一个消费者比后面的消费者分配到的分区更多一个按顺序分）
  
  
              《第5章》

1. kafka为什么效率更高，适合做实时数据处理？
  broker 将按照客户端指定的数量上限从分区里读取消息，再把消
息返回给客户端。 Kafka 使用零复制技术向客户端发送消息一一也就是说， Kafka 直接把消
息从文件（或者更确切地说是 Li ux 文件系统缓存）里发送到网络通道，而不需要经过任
何中间缓冲区。这是 Kafka 与其他大部分数据库系统不 样的地方，其他数据库在将数据
发送给客户端之前会先把它们保存在本地缓存里。这项技术避免了字节复制，也不需要管
理内存缓冲区

2. kafka几种常见的几种请求类型？
  元数据请求：
  生产请求和：
  获取请求：
  
  
3.kafka的几种分区分配机制
  

          《第6章》
 （1）. kafka的主题的复制系数默认是3,(也就是你必须得保证有3台broker,来进行保证每个分区在3台不同的broker中都有一份副本，这个可以根据你topic的重要程度来进行选择)
 
 （2）.在可靠的系统里使用生产者
        
  (3).kafka中的三种发送消息的确认模式：
      1.ack=0 这种模式就是有数据我就直接发送，我不管你有没有收到（一些特殊情况会出现数据的丢失），这样就保证了kafka的高吞吐量
      2.ack=1 意味若首领在收到消息（因为一个breaker中只有首领有权利收消息，其他都会备胎）并把它写入到分区数据文件（不 定同步到磁盘上）时，
        会返回确认或错误响应，如果在这种模式下，当首领正在换届的时候出现了异常，如果生产者能处理这个异常的话，那么生产者就会重试发送消息，
        但是这种模式也会出现丢失数据的情况（如果当消息已经被写入首领中，但是在消息被复制到跟随者中之前，首领发生了崩溃，那么此时这个数据就会丢失）
      3.ack=all 这种模式其实就是当首领在跟发消息的生产者打交道的时候，首领需要等全部的跟随者都收到消息，这种做法会降低kafka的吞吐量
      
      
      
      
      
《kafka的总结：为什么kafka效率比较高》
主要是kafka使用了零复制拷贝技术，在Linux内核kernel2.2之后，支持了一种零拷贝技术，可以直接不用经过用户空间进行拷贝技术，
只需要一次拷贝就让操作系统直接从内核读取缓冲区文件直接到网卡的缓冲区，中间不需要经过用户空间的复制
1.操作系统从磁盘读取数据到内核空间的 pagecache
2.应用程序读取内核空间的数据到用户空间的缓冲区
3.应用程序将数据(用户空间的缓冲区)写回内核空间到套接字缓冲区(内核空间)
4.操作系统将数据从套接字缓冲区(内核空间)复制到通过网络发送的 NIC 缓冲区


