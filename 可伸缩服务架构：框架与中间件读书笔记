《第一章》



《第二章:可扩展的消息队列框架的设计》

  （1）.
  
  
《第七章:dubbo实战以及源码的分析》  
  （1）.dubbo的实战
  （2）.dubbo的源码分析
    1.这个是服务的调用过程：
      首先服务消费者通过代理对象 Proxy 发起远程调用，接着通过网络客户端 Client 将编码后的请求发送给服务提供方的网络层上，
    也就是 Server。Server 在收到请求后，首先要做的事情是对数据包进行解码。然后将解码后的请求发送至分发器 Dispatcher，
    再由分发器将请求派发到指定的线程池上，最后由线程池调用具体的服务。这就是一个远程调用请求的发送与接收过程。至于响应的发送与接收过程，
    这张图中没有表现出来。对于这两个过程，我们也会进行详细分析。
    
    2.服务消费方发送请求：
      其实就是需要先进行包装一下dubbo的数据报，然后通过Netty进行发送数据
      到这里大家终于看到了 Request 语义了，上面的方法首先定义了一个 Request 对象，然后再将该对象传给 NettyClient 的 send 方法，
      进行后续的调用。需要说明的是，NettyClient 中并未实现 send 方法，该方法继承自父类 AbstractPeer
      
    3.服务提供方接收请求
      前面说过，默认情况下 Dubbo 使用 Netty 作为底层的通信框架。Netty 检测到有数据入站后，首先会通过解码器对数据进行解码，
      并将解码后的数据传递给下一个入站处理器的指定方法。所以在进行后续的分析之前，我们先来看一下数据解码过程。
      然后把解码得到的数据字段都封装到了Request对象中，
     调用服务：
      解码器将数据包解析成 Request 对象后，NettyHandler 的 messageReceived 方法紧接着会收到这个对象，
      并将这个对象继续向下传递。这期间该对象会被依次传递给 NettyServer、MultiMessageHandler、HeartbeatHandler 以及 AllChannelHandler。
      最后由 AllChannelHandler 将该对象封装到 Runnable 实现类对象中，并将 Runnable 放入线程池中执行后续的调用逻辑
    接受到请求之后，就开始进行请求的分发处理了：
      Dubbo 将底层通信框架中接收请求的线程称为 IO 线程。如果一些事件处理逻辑可以很快执行完，比如只在内存打一个标记，
      此时直接在 IO 线程上执行该段逻辑即可。但如果事件的处理逻辑比较耗时，比如该段逻辑会发起数据库查询或者 HTTP 请求。
      此时我们就不应该让事件处理逻辑在 IO 线程上执行，而是应该派发到线程池中去执行。原因也很简单，IO 线程主要用于接收请求，
      如果 IO 线程被占满，将导致它不能接收新的请求。Dispatcher 就是线程派发器
    到这里dubbo支持几种不同的线程分发策略：
      all	所有消息都派发到线程池，包括请求，响应，连接事件，断开事件等
      direct	所有消息都不派发到线程池，全部在 IO 线程上直接执行
      message	只有请求和响应消息派发到线程池，其它消息均在 IO 线程上执行
      execution	只有请求消息派发到线程池，不含响应。其它消息均在 IO 线程上执行
      connection	在 IO 线程上，将连接断开事件放入队列，有序逐个执行，其它消息派发到线程池
    把请求的之后返回的Response对象，其实这部分核心就是通过调用Invoker（）生成Invoker实例对象来得到返回对象调用：
      到这里，我们看到了比较清晰的请求和响应逻辑。对于双向通信，HeaderExchangeHandler 首先向后进行调用，得到调用结果。
      然后将调用结果封装到 Response 对象中，最后再将该对象返回给服务消费方。如果请求不合法，或者调用失败，则将错误信息封装到 Response 对象中，
      并返回给服务消费方。接下来我们继续向后分析，把剩余的调用过程分析完。下面分析定义在 DubboProtocol 类中的匿名类对象逻辑
      
    4.服务提供方返回调用结果
      服务提供方调用指定服务后，会将调用结果封装到 Response 对象中，并将该对象返回给服务消费方。
      服务提供方也是通过 NettyChannel 的 send 方法将 Response 对象返回，这个方法在 2.2.1 节分析过，这里就不在重复分析了。
      本节我们仅需关注 Response 对象的编码过程即可，这里仍然省略一些中间调用
      
    5.服务消费方接收调用结果
      服务消费方在收到响应数据后，首先要做的事情是对响应数据进行解码，得到 Response 对象。然后再将该对象传递给下一个入站处理器，
      这个入站处理器就是 NettyHandler。接下来 NettyHandler 会将这个对象继续向下传递，最后 AllChannelHandler 的 received 方法会收到这个对象，
      并将这个对象派发到线程池中。这个过程和服务提供方接收请求的过程是一样的，因此这里就不重复分析了。
      本节我们重点分析两个方面的内容，一是响应数据的解码过程，二是 Dubbo 如何将调用结果传递给用户线程的
    向用户线程传递调用结果：
      响应数据解码完成后，Dubbo 会将响应对象派发到线程池上。要注意的是，线程池中的线程并非用户的调用线程，
      所以要想办法将响应对象从线程池线程传递到用户线程上。我们在 2.1 节分析过用户线程在发送完请求后的动作，
      即调用 DefaultFuture 的 get 方法等待响应对象的到来。当响应对象到来后，用户线程会被唤醒，并通过调用编号获取属于自己的响应对象
    以上逻辑是将响应对象保存到相应的 DefaultFuture 实例中，然后再唤醒用户线程，随后用户线程即可从 DefaultFuture 实例中获取到相应结果。
      
    
    
    
    
    
    
    
  
